<h1 id="intro-to-docker">Intro to Docker</h1>
<p>In this activity, you will create two docker images and deploy two
containers, one from each image. One image will be a dev environment and
the other testing. Both containers will be a web server serving
different content on the same host operating system.</p>
<p>This activity demonstrates the power of containerization and the
ability to run multiple services on a single host operating system.</p>
<p>Containerization allows us to run images on the host operating
system. A major benefit of containerization is that containers use the
same hardware (kernel) as the host operating system. Containers.</p>
<p>Images allow bundling up packages or installation instructions into a
file, eliminating the need to perform installation steps on the host OS
or create dependency conflicts. It is important to note that images and
containerization do not necessarily rely on Docker. Docker is just a
suite of tools for creating and deploying images into containers.
Kubernetes, for example, can use the same images but uses a different
runtime for running the containers.</p>
<h2 id="learning-objectives">Learning Objectives</h2>
<p>You will be able to create a dockerfile, build images, deploy
multiple containers on the same host OS and understand different
keywords in dockerfiles. Completing the bonus portion will teach you
about volumes between containers and the host OS.</p>
<h2 id="setup">Setup</h2>
<ul>
<li>Make sure that you have ports 80 and 8080 open on your host OS
firewall before starting this activity. If on AWS navigate to your
instance, then Security, and click on your Security Group. Edit inbound
rules, then verify or add a rule for ports 8080 and 80. For the source
select “Anywhere IPv4”. Save your settings.</li>
</ul>
<ol type="1">
<li><ul>
<li><pre class="prettyprint"><code class>sudo yum -y update</code></pre></li>
<li><pre class="prettyprint"><code class>sudo yum -y install docker</code></pre></li>
<li><pre class="prettyprint"><code class>sudo service docker start</code></pre></li>
</ul>
<blockquote>
<p>If you want to run docker without sudo (recommended) add your user to
the docker group by running <pre class="prettyprint"><code class>sudo usermod -aG docker $USER</code></pre>.
You will then need to log out and log back in.</p>
</blockquote></li>
<li></li>
<li><ul>
<li><pre class="prettyprint"><code class>mkdir dev-site test-site</code></pre></li>
</ul></li>
</ol>
<h1 id="test-site">Test Site</h1>
<p>Start with the test website.</p>
<ol type="1">
<li><ul>
<li><pre class="prettyprint"><code class>cd test-site</code></pre></li>
</ul></li>
<li></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker build -t test-httpd .</code></pre> &gt; This command
searches for a file named dockerfile in the current directory, builds it
and tags (-t) the image as <em>test-httpd</em></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker images</code></pre></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker run -dit --name test-httpd-container -p 80:80 test-httpd</code></pre>
&gt; The -d tells it to run in background, -it allows the continer to
connect to your terminal session. &gt; -p is the bort binding, above we
are binding port 80 of the host OS to port 80 on the container.</li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker ps -a</code></pre>
<ul>
<li>Notice that port 80 of the host is routed to port 80 of the
container. The -a is to display all details.</li>
</ul></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>http://&lt;YOUR_PUBLIC_IP&gt;</code></pre></li>
</ul></li>
</ol>
<h1 id="dev-site">Dev Site</h1>
<p>This website will serve our own HTML files.</p>
<h2 id="instructions">Instructions</h2>
<ol type="1">
<li><ul>
<li><pre class="prettyprint"><code class>cd ~/dev-site</code></pre></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>mkdir public-html</code></pre></li>
<li><pre class="prettyprint"><code class>cd public-html</code></pre></li>
</ul></li>
<li></li>
<li><ul>
<li><pre class="prettyprint"><code class>cd ~/dev-site</code></pre></li>
</ul></li>
<li><blockquote>
<p>The <strong>ENV</strong> keyword sets an enviornment variable that we
can access later with $cohort. The <strong>RUN</strong> keyword executes
a command when building the image, such as sed. Here we are replacing
<pre class="prettyprint"><code class>&lt;COHORT&gt;</code></pre> with the value of $cohort for each file in
htdocs. <strong>EXPOSE</strong> opens the port 80 of the container, it
is not needed here because the base image already exposes that port.</p>
</blockquote>
<blockquote>
<p>The <strong>CMD</strong> keyword should only be used once, it is
different from RUN because it is not executed while the image is being
build. Instead, CMD is the command to run when the image is executed as
a container. This is known as the main process, and when this process is
done executing the container will stop. To keep your container alive,
this command should not exit. In this case <pre class="prettyprint"><code class>httpd-foreground</code></pre>
is the same command the base image executes. Therefore, the entire line
can be removed since the base image already executes the
<pre class="prettyprint"><code class>httpd-foreground</code></pre> command.</p>
</blockquote>
<blockquote>
</blockquote></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker build -t dev-httpd .</code></pre></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker images</code></pre></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker run -dit --name dev-httpd-container -p 8080:80 dev-httpd</code></pre></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>sudo docker ps -a</code></pre>
<ul>
<li>Notice that port 8080 of the host OS is being routed to port 80 of
the dev-httpd container. The httpd service is already configured to
listen on port 80. Now all requests to port 8080 are forwarded to port
80 of the container.</li>
</ul></li>
</ul></li>
<li><ul>
<li><pre class="prettyprint"><code class>http://&lt;YOUR_PUBLIC_IP&gt;:8080</code></pre></li>
</ul></li>
</ol>
<h1 id="volumes-bonus">Volumes (Bonus)</h1>
<p>A volume is a shared folder between the host OS or other containers.
We can create a volume from public-html on the host OS to htdocs on the
container. A volume could enable editing the files in the public-html
folder and reflecting the changes in the htdocs folder of the
container.</p>
<p>Without using volumes you would have to rebuild the image and
container each time you changed the file because the dockerfile (and
<pre class="prettyprint"><code class>COPY</code></pre> command) is only executed at image creation
(<pre class="prettyprint"><code class>docker build</code></pre>). You could edit the files in the container,
but that requires <pre class="prettyprint"><code class>docker exec</code></pre> and volumes are still more
convenient.</p>
<h2 id="instructions-1">Instructions</h2>
<p>The activity walks you through editing the web page on the host
before adding a volume. Then you will edit the file after adding a
volume and compare the difference. This activity uses the dev
environment only.</p>
<ol type="1">
<li><ul>
<li><pre class="prettyprint"><code class>vim ~/dev-site/public-html/index.html</code></pre></li>
</ul></li>
<li></li>
<li></li>
</ol>
<div class="sourceCode" id="cb1"><pre class="prettyprint"><code class>sudo docker rm -f dev-httpd-container
sudo docker run -dit -v /home/ec2-user/dev-site/public-html:/usr/local/apache2/htdocs \
--name dev-httpd-container -p 8080:80 dev-httpd</code></pre></div>
<ol start="4" type="1">
<li>Edit the host HTML file again with a noticeable change.
<ul>
<li><pre class="prettyprint"><code class>vim ~/dev-site/public-html/index.html</code></pre></li>
</ul></li>
<li>Visit <pre class="prettyprint"><code class>http://&lt;YOUR_PUBLIC_IP&gt;:8080</code></pre> and take note
if the changes made in step 1 and step 4 are visible.</li>
</ol>
<h1 id="cleanup">Cleanup</h1>
<ol type="1">
<li>Stop the docker containers.
<ul>
<li><pre class="prettyprint"><code class>sudo docker stop dev-httpd-container test-httpd-container</code></pre>
&gt; To start a stopped container use
<pre class="prettyprint"><code class>sudo docker start &lt;CONTAINER_NAME&gt;</code></pre></li>
</ul></li>
<li>Delete the containers.
<ul>
<li><pre class="prettyprint"><code class>sudo docker rm dev-httpd-container test-httpd-container</code></pre>
&gt; You could have stopped and deleted in one step with -f</li>
</ul></li>
<li>Delete the images.
<ul>
<li><pre class="prettyprint"><code class>sudo docker rmi dev-httpd test-httpd httpd:2.4</code></pre></li>
</ul></li>
<li>Now run these commands to verify you have deleted the images and the
containers.
<ul>
<li><pre class="prettyprint"><code class>sudo docker ps -a</code></pre></li>
<li><pre class="prettyprint"><code class>sudo docker images</code></pre></li>
</ul></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>In this activity you created a basic test docker container and
verified it was accessible over the internet. You then created another
container from a more sophisticated dockerfile on the same host OS. If
you completed the bonus you added a volume linking a host directory to a
container and updated the website via the host OS. Finally, you
performed the operations needed to remove the containers and images.
These skills are essential for navigating modern microservice
stacks.</p>
